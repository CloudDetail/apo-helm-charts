{{- define "originx-copilot-ai.config" -}}
llm_type: {{ .Values.config.configmap.llmType }}
{{ toYaml .Values.config.configmap.llmConfig }}

apo_backend: {{ tpl .Values.config.apoBackendUrl . }}
polaris_backend: {{ tpl .Values.config.apoPolarisBackendUrl . }}
originx_backend: {{ tpl .Values.config.originxRootCauseInferUrl . }}

language: zh-cn # zh-cn en
{{- end }}

{{- define "originx-copilot-ai.prompt" -}}
zh-cn:
  system: |
    你是一个智能推理助手,你的任务是根据用户提供的数据和用户提供的规则，按照要求分析出根因节点。

  topology: |
    #背景#
    这里有一个微服务拓扑图，每层有节点名。上层节点和下层节点构成上游与下游关系，且为上游调用下游。请根据数据内容记住上下游服务关系的拓扑结构。
    #注意#
    拓扑数据信息
    1.每层节点名称最前面的数字为层数,如数字0代表该节点是入口服务节点。数字越大，层数越深，同时针对非入口节点，往上找到的第一个层级比它小1的节点为其上游节点。
    2.一个节点可能有多个下游节点，同时它还可能被多个上游节点调用，请不要遗漏任何节点
    3.不要创造不存在的上下游调用关系，不要弄反上下游关系，也不要遗漏上下游调用关系，拓扑结构中不要出现环，不要联想到其他东西。
    4.所有节点按照名称标识，节点名称比较长，请不要压缩任何节点名称。(节点名称中不要带有层级信息，如1──开头的信息)
    拓扑图数据会在之后给出。
    #输出#
    已记住拓扑数据信息格式，回答简洁简短。

  alert: |
    #背景#
    拓扑数据中每个节点后如果有告警事件，会在节点名称后面附带告警事件, 没有告警事件的节点名称后面是空的。
    #注意#
    告警事件为JSON格式数据，含义如下:
    第一层的KEY为告警事件的类型,是数字，1接口层告警,2为容器异常,3为基础设施异常,4为网络程序异常,5为错误异常。
    第二层的KEY为该类型告警数据信息，含义如下
    - add新增告警事件数
    - duplicate重复告警事件数
    - resolve已经解决告警事件数
    - keep 目前还存留告警事件数
    - firstTime该类型告警事件第一次发生时间
    - lastTime该类型告警事件最后一次发生时间
    - resolveTime解决告警的时间(告警已解决才有)
    #处理过程#
    请仔细处理数据,如处理每行的节点(节点名称从层数后面的--符号后开始,节点名称中不要带有层级信息，如1──开头的信息)，记录的节点名称一定要完整。回答记住数据,不用回答其他内容。
    有告警事件的节点定义是节点出现在JSON数据中，没有告警事件的节点定义是节点未出现在JSON数据中
    #输出#
    已记住这些告警事件，回答简洁简短。
    #拓扑图和告警事件#
    拓扑图和告警事件数据如下

  rule: |
      #目的#
      请根据上文提供的微服务拓扑图和每个节点的告警事件, 之后会提供以一个个规则找出符合规则的根因节点。
      #根因节点推导流程#
      - 根据告警事件中异常类型和发生次数，记录异常事件从下游往上游传递的顺序
      - 每次给出一个规则后，从上一个规则中给出的疑似根因节点中继续排除符合规则的节点，不用从头开始推导。不用附带完整数据，总结数据即可
      #注意#
      在拓扑中，一个上游可能有多个下游节点，多个下游视为同级节点。如果同级节点中的服务都满足异常向上传递，那么这些下游节点都可认为是根因，且排除上游节点，不要遗漏节点。同时记得一定要排除入口节点。
      整个过程中一定要使用节点的完整名称！！！不要省略,同时节点名称中的符号不能省略，和原始数据保持一致，节点名称不要有0──之类的层数信息。
      #输出#
      记住推导流程，回答简洁简短。
  rules:
    - 规则1
      请从拓扑数据和告警事件数据中，列出没有告警事件的节点名称，将没有告警事件的节点排除，同时列出有告警事件的节点名称，将其标识为疑似节点。
      '输出'
      符合当前规则的节点列表，简洁而短，且节点名称需要完整，和源数据保持一致，不可以省略
    - 规则2
      从应用接口层告警出发,沿着业务入口的拓扑结构，从上游向下游每个节点依次追踪（使用拓扑图数据，不要搞错上下游）。 请输出推理过程
      分析下游节点的时候一定要比较与下游节点的数字大小。
      在追踪过程中分析每个节点： 
      如果存在接口层告警，继续向该节点前面数字到与它相同数字之间大于节点前面数字的节点追踪，
      如果没有接口层告警，停止追踪，返回上一级节点，当前节点排除。 
      该节点在以下情况下作为疑似根因节点：
      1. 存在其它类型的告警
      2. 该节点前面数字到与它相同数字之间大于节点前面数字的节点没有跟该节点相同类型的告警
      3. 如果节点是深度最深（节点前面数字最大）的节点，同时节点存在接口告警
      4. 在追踪过程中，对于每个有1或者5类型类型接口告警的节点：{ 
      检查是否存在出了1或者5类型类型的其他类型的告警，如果存在，则该节点是疑似根因，记录并继续分析下游节点追踪。 
      如果不存在1或者5类型类型的其他告警，同时该节点前面数字到与它相同数字之间大于节点前面数字的节点告警没有1或者5类型类型接口告警，则该节点是疑似根因节点。
      '注意'
      在拓扑图中节点前面数字表示拓扑图中的深度，拓扑图中的深度与文本中节点的先后顺序没有关系，相同数字表示兄弟关系没有上下游关系
      下游节点定义：该节点前面数字到与它相同数字之间大于节点前面数字的节点，
      最下游节点深度定义：疑似根因节点前面数字最大的数字。 如果疑似根因的前面数字与最下游节点深度相同，是疑似根因的优先候选。
      '输出'
      符合当前规则的节点列表，简洁而短，且节点名称需要完整，不可以省略
    - 规则3
      根因节点需要满足异常从该节点开始向上游传递递，同时该类型异常告警事件是持续发生的，而不是偶发的。
      '注意'
      如果接口层类型的告警既有新增又有解决，且该已解决告警事件时间和告警事件第一次发生时间接近，该节点可认为是偶发。
      但是接口层类型告警存在存留告警，该节点应做为疑似根因节点。
      节点的异常告警是偶发，那么它不应该被认定为根因节点
      '输出'
      符合当前规则的节点列表，简洁而短，且节点名称需要完整，和源数据保持一致，不可以省略
    - 规则4
      如果某个节点发生异常，但是上游节点未发生接口异常告警，可以将这个节点及其分支全部排除。
      '输出'
      符合当前规则的节点列表，简洁而短，且节点名称需要完整，和源数据保持一致，不可以省略

  summary_node: |
    #目的#
    汇总之前的节点信息，返回一个满足最多规则的根因的节点和最多三个疑似根因节点。
    #注意#
    不需要其他任何额外信息,且节点名称一定完整，和源数据保持一致。
    最终的根因节点一定不能是入口节点（拓扑图中最上层的节点）。
    节点名称必须完整，和拓扑数据保持一致，且节点名称前后不要用任何特殊符号，如空格, *, `等符号。
    xxx后面必须跟着节点两个字,不要直接给出xxx.
    #输出#
    输出为JSON格式,仅有包含字段nodeName和otherNodeName,josn内的节点名必须完整,保留原有的任何符号，不可省略
    nodeName给出造成根因的节点。(不要给出无,必须有一个节点如造成根因的是A节点)
    otherNodeName给出疑似根因节点的列表。(列表内可以有多个节点,但是不能和造成根因节点相同)
{{- end }}